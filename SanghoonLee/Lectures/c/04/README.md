# 모든것은 포인터다(feat by 상훈)
gcccompil3r@gmail.com  

ㅇㅇ 내가 만듬  

## 포인터 통일론
해당 내용을 통해서 결국 C언어의 모든 것이  
포인터라는 것을 확인할 수 있을 것이다.  
이중 포인터, 삼중 포인터, 배열, 다중 배열,  
포인터 배열, 함수 포인터를 별개로 볼 필요가 없다.  
다만 이것을 진행하기 위해서는 몇 가지 개념이 필요하다.  

```make
1. 메모리 계층 구조
2. 스택(Stack)은 아래로 자란다.
3. GP Register에 대한 명확한 개념과 각각의 용도
```

## 디버깅 명령어
```make
info registers:

실제 HW 레지스터 정보를 확인할 수 있고
여기서는 펌웨어 제어와 관련된 레지스터 정보는 보여주지 않는다.
우리가 이 내용을 진행하면서 주의를 둘 부분은 아래와 같다.

rsp, rbp, rip, rax, rcx 정도에 해당한다.

rsp: 현재 스택의 최상위
rbp: 현재 스택의 기준점
rip: 다음에 실행할 instruction의 주소값을 가르킴
rax: 무조건적으로 함수의 리턴값이 저장되며 연산용으로도 활용 가능
rcx: 보편적으로 for 루프의 카운트에 활용이 되며 연산용으로도 활용 가능

si: 어셈블리 명령어 기준으로 한 줄씩 실행한다.  
p/x: 16진수로 특정 결과를 출력한다.  
x: 메모리의 내용을 살펴본다.  
```

## 디버깅 과정
```make
=> 0x000055555555515b <+0>:	endbr64 
   0x000055555555515f <+4>:	push   %rbp
   0x0000555555555160 <+5>:	mov    %rsp,%rbp
   0x0000555555555163 <+8>:	sub    $0x10,%rsp
   0x0000555555555167 <+12>:	movl   $0x3,-0x8(%rbp)
   0x000055555555516e <+19>:	mov    -0x8(%rbp),%eax
   0x0000555555555171 <+22>:	mov    %eax,%edi
   0x0000555555555173 <+24>:	callq  0x555555555149 <my_func>
   0x0000555555555178 <+29>:	mov    %eax,-0x4(%rbp)
   0x000055555555517b <+32>:	mov    -0x4(%rbp),%eax
   0x000055555555517e <+35>:	mov    %eax,%esi
   0x0000555555555180 <+37>:	lea    0xe7d(%rip),%rdi        # 0x555555556004
   0x0000555555555187 <+44>:	mov    $0x0,%eax
   0x000055555555518c <+49>:	callq  0x555555555050 <printf@plt>
   0x0000555555555191 <+54>:	mov    $0x0,%eax
   0x0000555555555196 <+59>:	leaveq 
   0x0000555555555197 <+60>:	retq
```

먼저 push rbp로 이동을 해본다.  
이후 rsp값을 기록한다: 0x7fffffffdb88  
다음에 새로 시작하면 값이 바뀔수도 있으니 주의한다.  

push 명령어는 현재 스택의 최상위 메모리에 값을 저장하는 명령어  

```make
-------------------
|     0x0(rbp)    | 0x7fffffffdb80
-------------------
```

mov 명령어는 내용을 복사한다.  
mov rsp, rbp를 통해서 rbp에 rsp값을 복사한다.  
결국 rsp, rbp값이 서로 같아지며 스택의 경계선이 사라진다.  
실제로는 새로운 스택을 생성할 준비를 하는 과정임  

sub 명령어는 뺄셈 명령어다.  
sub 0x10, rsp는 현재 rsp에서 16바이트를 빼겠다는 의미다.  

```make
-------------------
|     0x0(rbp)    | 0x7fffffffdb80
-------------------
|                 | <<<--- sub으로 만든 공간이 지역 변수 공간으로 쓰는 메모리 공간
-------------------
|                 | 0x7fffffffdb70
-------------------
```

다음으로 movl $0x3,-0x8(%rbp)이 보인다.  
l이 들어가면 4바이트 처리를 하겠다는 의미이며  
q가 들어가면 8바이트 처리를 하겠다는 뜻이 된다.  
rbp를 기준으로 8바이트 뺀 자리에 0x3을 복사한다.  

```make
-------------------
|     0x0(rbp)    | 0x7fffffffdb80
-------------------
|     0x3(num)    | 0x7fffffffdb78
-------------------
|                 | 0x7fffffffdb70
-------------------
```

다음으로 mov -0x8(%rbp),%eax는  
eax레지스터(4바이트 레지스터)에 0x3을 넣겠다는 뜻  
연산 이후 ax 레지스터를 확인하면 변경된 값을 볼 수 있다.  

mov eax, edi는 그냥 복사이므로 edi에 3이 들어간다.  

callq  0x555555555149 은 매우 중요한 연산이다.  
call은 기본적으로 push + jmp로 구성되어 있다.  
함수 호출이 끝난 이후에 실행해야할 어셈블리 명령어의 주소값을 push로 저장한다.  
이후 함수 호출을 수행하기 위해 jmp를 수행한다.  

결국 아래와 같은 메모리를 가지게 된다.  

```make
--------------------------------
|            0x0(rbp)          | 0x7fffffffdb80
--------------------------------
|            0x3(num)          | 0x7fffffffdb78
--------------------------------
|                              | 0x7fffffffdb70
--------------------------------
| 0x0000555555555178(복귀주소) | 0x7fffffffdb68
--------------------------------
```

함수 호출후 보이는 어셈은 아래와 같다.  

```make
   0x0000555555555149 <+0>:	endbr64 
=> 0x000055555555514d <+4>:	push   %rbp
   0x000055555555514e <+5>:	mov    %rsp,%rbp
   0x0000555555555151 <+8>:	mov    %edi,-0x4(%rbp)
   0x0000555555555154 <+11>:	mov    -0x4(%rbp),%eax
   0x0000555555555157 <+14>:	sar    %eax
   0x0000555555555159 <+16>:	pop    %rbp
   0x000055555555515a <+17>:	retq  
```

push rbp를 진행하게 되면 rsp값이 추가로 8 바이트 빠지므로
메모리는 아래와 같은 구성을 하게 될 것이다.  
또한 기존의 스택의 기준점인 rbp를 저장하게 된다.  

```make
----------------------------------
|             0x0(rbp)           | 0x7fffffffdb80 <<<- rbp
----------------------------------
|             0x3(num)           | 0x7fffffffdb78
----------------------------------
|                                | 0x7fffffffdb70
----------------------------------
|  0x0000555555555178(복귀주소)  | 0x7fffffffdb68
----------------------------------
| 0x7fffffffdb80(이전 함수의rbp) | 0x7fffffffdb60
----------------------------------
```

이후 다시 mov rsp, rbp를 하면 새로운 rbp가 생성된다.  
이것이 my_func에 해당하는 새로운 스택의 기준점이 된다.  
결국 함수를 호출할 때마다 스택을 새롭게 생성한다는 것이 되며  
우리가 포인터를 사용하는 이유는  
바로 이 경계선을 넘어 자유롭게 왔다갔다 할 수 있기 때문이다.  

```make
----------------------------------
|             0x0(rbp)           | 0x7fffffffdb80
----------------------------------
|             0x3(num)           | 0x7fffffffdb78
----------------------------------
|                                | 0x7fffffffdb70
----------------------------------
|  0x0000555555555178(복귀주소)  | 0x7fffffffdb68
----------------------------------
| 0x7fffffffdb80(이전 함수의rbp) | 0x7fffffffdb60 <<<- my_func의 rbp
----------------------------------
```

이후 edi값을 rbp-4 위치에 배치한다.  
edi에는 eax에서 옮겨온 인자값 3이 배치됨  

```make
----------------------------------
|             0x0(rbp)           | 0x7fffffffdb80
----------------------------------
|             0x3(num)           | 0x7fffffffdb78
----------------------------------
|                                | 0x7fffffffdb70
----------------------------------
|  0x0000555555555178(복귀주소)  | 0x7fffffffdb68
----------------------------------
| 0x7fffffffdb80(이전 함수의rbp) | 0x7fffffffdb60 <<<- my_func의 rbp
----------------------------------
|  0x3(num 아니고 my_func의 num) | 0x7fffffffdb5c
----------------------------------
```

sar은 Shift Arithmetic Right의 약자로 오른쪽 쉬프트다.  
sar    %eax의 경우 뒤쪽에 비트가 표현이 안되어 있으므로 기본적으로 1이다.  

eax는 3이므로 결과는 1이 될 것이다.  
ax는 함수의 리턴값을 가진다고 했다.  
실제로 이 값은 my_func이 리턴하는 값에 해당한다.  

다음으로 pop    %rbp를 수행하는데 pop은 현재 rsp에서 값을 빼서  
뒤쪽에 배치된 메모리나 레지스터에 값을 넘겨준다.  

결국 값을 빼내기 때문에 rsp값은 60에서 68로 증가하게 되고  
내부에 있는 값은 rbp로 들어가므로 이전의 rbp가 복원된다.  
(결국 스택을 복원하는 작업의 일부에 해당함)  

이 시점의 메모리는 다음과 같다.  

```make
----------------------------------
|             0x0(rbp)           | 0x7fffffffdb80 <<<--- rbp
----------------------------------
|             0x3(num)           | 0x7fffffffdb78
----------------------------------
|                                | 0x7fffffffdb70
----------------------------------
|  0x0000555555555178(복귀주소)  | 0x7fffffffdb68 <<<--- rsp
----------------------------------
| 0x7fffffffdb80(이전 함수의rbp) | 0x7fffffffdb60
----------------------------------
|  0x3(num 아니고 my_func의 num) | 0x7fffffffdb5c
----------------------------------
```

다음으로 retq를 진행하는데 retq는 아래와 같은 의미를 가진다.  
pop rip에 해당하는 연산이다.  
메모리를 보면 아래와 같다.  

```make
----------------------------------
|             0x0(rbp)           | 0x7fffffffdb80 <<<--- rbp
----------------------------------
|             0x3(num)           | 0x7fffffffdb78
----------------------------------
|                                | 0x7fffffffdb70 <<<--- rsp
----------------------------------
|  0x0000555555555178(복귀주소)  | 0x7fffffffdb68
----------------------------------
| 0x7fffffffdb80(이전 함수의rbp) | 0x7fffffffdb60
----------------------------------
|  0x3(num 아니고 my_func의 num) | 0x7fffffffdb5c
----------------------------------
```

복귀후 rbp-4자리에 리턴값인 ax 레지스터를 배치한다.  
메모리 구조는 아래와 같이 보일 것이다.  

```make
----------------------------------
|             0x0(rbp)           | 0x7fffffffdb80 <<<--- rbp
----------------------------------
|             0x1(res)           | 0x7fffffffdb7c
----------------------------------
|             0x3(num)           | 0x7fffffffdb78
----------------------------------
|                                | 0x7fffffffdb70 <<<--- rsp
----------------------------------
|  0x0000555555555178(복귀주소)  | 0x7fffffffdb68
----------------------------------
| 0x7fffffffdb80(이전 함수의rbp) | 0x7fffffffdb60
----------------------------------
|  0x3(num 아니고 my_func의 num) | 0x7fffffffdb5c
----------------------------------
```

결국 핵심은 특정한 메모리 주소값에 어떤 값이 있다.  
이것이 시작이고 끝이고 결론이다.  
