# 모든것은 포인터다(feat by 상훈)
gcccompil3r@gmail.com  

ㅇㅇ 내가 만듬  

## 포인터 통일론
해당 내용을 통해서 결국 C언어의 모든 것이  
포인터라는 것을 확인할 수 있을 것이다.  
이중 포인터, 삼중 포인터, 배열, 다중 배열,  
포인터 배열, 함수 포인터를 별개로 볼 필요가 없다.  
다만 이것을 진행하기 위해서는 몇 가지 개념이 필요하다.  

```make
1. 메모리 계층 구조
2. 스택(Stack)은 아래로 자란다.
3. GP Register에 대한 명확한 개념과 각각의 용도
```

## 디버깅 명령어
```make
info registers:

실제 HW 레지스터 정보를 확인할 수 있고
여기서는 펌웨어 제어와 관련된 레지스터 정보는 보여주지 않는다.
우리가 이 내용을 진행하면서 주의를 둘 부분은 아래와 같다.

rsp, rbp, rip, rax, rcx 정도에 해당한다.

rsp: 현재 스택의 최상위
rbp: 현재 스택의 기준점
rip: 다음에 실행할 instruction의 주소값을 가르킴
rax: 무조건적으로 함수의 리턴값이 저장되며 연산용으로도 활용 가능
rcx: 보편적으로 for 루프의 카운트에 활용이 되며 연산용으로도 활용 가능

si: 어셈블리 명령어 기준으로 한 줄씩 실행한다.  
p/x: 16진수로 특정 결과를 출력한다.  
x: 메모리의 내용을 살펴본다.  
```

## 디버깅 과정
```make
=> 0x000055555555515b <+0>:	endbr64 
   0x000055555555515f <+4>:	push   %rbp
   0x0000555555555160 <+5>:	mov    %rsp,%rbp
   0x0000555555555163 <+8>:	sub    $0x10,%rsp
   0x0000555555555167 <+12>:	movl   $0x3,-0x8(%rbp)
   0x000055555555516e <+19>:	mov    -0x8(%rbp),%eax
   0x0000555555555171 <+22>:	mov    %eax,%edi
   0x0000555555555173 <+24>:	callq  0x555555555149 <my_func>
   0x0000555555555178 <+29>:	mov    %eax,-0x4(%rbp)
   0x000055555555517b <+32>:	mov    -0x4(%rbp),%eax
   0x000055555555517e <+35>:	mov    %eax,%esi
   0x0000555555555180 <+37>:	lea    0xe7d(%rip),%rdi        # 0x555555556004
   0x0000555555555187 <+44>:	mov    $0x0,%eax
   0x000055555555518c <+49>:	callq  0x555555555050 <printf@plt>
   0x0000555555555191 <+54>:	mov    $0x0,%eax
   0x0000555555555196 <+59>:	leaveq 
   0x0000555555555197 <+60>:	retq
```

먼저 push rbp로 이동을 해본다.  
이후 rsp값을 기록한다: 0x7fffffffdb88  
다음에 새로 시작하면 값이 바뀔수도 있으니 주의한다.  

push 명령어는 현재 스택의 최상위 메모리에 값을 저장하는 명령어  

```make
-------------------
|     0x0(rbp)    | 0x7fffffffdb80
-------------------
```

mov 명령어는 내용을 복사한다.  
mov rsp, rbp를 통해서 rbp에 rsp값을 복사한다.  
결국 rsp, rbp값이 서로 같아지며 스택의 경계선이 사라진다.  
실제로는 새로운 스택을 생성할 준비를 하는 과정임  

sub 명령어는 뺄셈 명령어다.  
sub 0x10, rsp는 현재 rsp에서 16바이트를 빼겠다는 의미다.  

```make
-------------------
|     0x0(rbp)    | 0x7fffffffdb80
-------------------
|                 | <<<--- sub으로 만든 공간이 지역 변수 공간으로 쓰는 메모리 공간
-------------------
|                 | 0x7fffffffdb70
-------------------
```

다음으로 movl $0x3,-0x8(%rbp)이 보인다.  
l이 들어가면 4바이트 처리를 하겠다는 의미이며  
q가 들어가면 8바이트 처리를 하겠다는 뜻이 된다.  
rbp를 기준으로 8바이트 뺀 자리에 0x3을 복사한다.  

```make
-------------------
|     0x0(rbp)    | 0x7fffffffdb80
-------------------
|     0x3(num)    | 0x7fffffffdb78
-------------------
|                 | 0x7fffffffdb70
-------------------
```

다음으로 mov -0x8(%rbp),%eax는  
eax레지스터(4바이트 레지스터)에 0x3을 넣겠다는 뜻  
연산 이후 ax 레지스터를 확인하면 변경된 값을 볼 수 있다.  

mov eax, edi는 그냥 복사이므로 edi에 3이 들어간다.  

callq  0x555555555149 은 매우 중요한 연산이다.  
call은 기본적으로 push + jmp로 구성되어 있다.  
함수 호출이 끝난 이후에 실행해야할 어셈블리 명령어의 주소값을 push로 저장한다.  
이후 함수 호출을 수행하기 위해 jmp를 수행한다.  

결국 아래와 같은 메모리를 가지게 된다.  

```make
--------------------------------
|            0x0(rbp)          | 0x7fffffffdb80
--------------------------------
|            0x3(num)          | 0x7fffffffdb78
--------------------------------
|                              | 0x7fffffffdb70
--------------------------------
| 0x0000555555555178(복귀주소) | 0x7fffffffdb68
--------------------------------
```
















