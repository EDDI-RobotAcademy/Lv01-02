# 변수란 무엇일까요 ?

## 여러분들이 생각하는 변수는 뭔가요 ?

1. 알려지지 않은 값  
2. 변하는 값  
3. x, y, z ... 등등  

```make
정답: 특정한 데이터 타입을 저장할 수 있는 메모리 공간
```

## 위의 정의가 중요한 이유가 무엇일까 ?

1. 포인터 변수 ===> 특정한 타입의 메모리 주소를 저장할 수 있는 메모리 공간   
2. 배열 변수 ===> 특정한 타입의 연속된 메모리 주소를 저장할 수 있는 메모리 공간  
3. 변수 ===> 특정한 타입을 저장할 수 있는 메모리 공간  
4. 함수 포인터 변수 ===> 특정한 프로토타입의 함수 주소를 저장할 수 있는 메모리 공간  

## 그렇다면 메모리는 무엇일까 ?

메모리 계층 구조에 보면 속도순으로 아래와 같다.  
Register > Cache > Memory(DRAM) > Disk  
우리가 프로그래밍을 하며 메모리라 부르는 영역은 바로 Memory(DRAM)에 해당한다.  

## 실제로 c 프로그램에서 보는 메모리는 가짜다!

가짜라고 말한 이유는 진짜 DRAM에 올라가는 물리 메모리와 다르게  
가상의 메모리로 데이터를 사용하고 있기 때문이다.  

## 그렇다면 메모리에는 어떤식으로 프로그램이 배치가 될까 ?

아래와 같은 프로그램의 메모리가 어떻게 배치되는지 살펴보자!  

```c
#include <stdio.h>

int main(void)
{
	int data = 3;

	printf("data = %d\n", data);

	return 0;
}
```

위 프로그램의 경우엔 변수에 3을 저장하고 있다.  
이 데이터는 메모리 상에 아래와 같이 배치된다.
(현재 여기서 메모리라 부르는 것은 가상 메모리라는 것을 상기하자!)
물리 메모리에 대한 개념은 리눅스 디바이스 드라이버를 만들면서 학습하게 될 것이다.  

ㅡㅡㅡㅡㅡㅡㅡㅡ  
|⠀⠀⠀⠀3⠀⠀⠀⠀⠀| 가상 메모리 주소(0xbf238293944488f0)  
ㅡㅡㅡㅡㅡㅡㅡㅡ  

이와 같은 형식으로 저장이 된다.  
만약 포인터라면 아래와 같이 배치된다.  

```c
#include <stdio.h>

int main(void)
{
	int data = 7;
	int *p = &data;

	printf("*p = %d\n", *p);

	return 0;
}
```

위의 케이스는 일반 변수와 포인터 변수가 함께 동작하는 상황이다.  
이에 대한 메모리 구조는 아래와 같다.  

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
|⠀⠀⠀⠀⠀⠀⠀⠀⠀7⠀⠀⠀⠀⠀⠀⠀⠀| 가상 메모리 주소(0xbf238293944488f0)  
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  
|⠀⠀⠀0xbf238293944488f0⠀⠀| 가상 메모리 주소(0xbf238293944488e8)  
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ  

이와 같은 형식으로 메모리상에 배치가 됩니다.  

# 가상 메모리에 대한 질문

## 먼저 파악해야할 것들

1. 비트수 기반으로 가상 메모리 결정하는 방법  
2. 포인터의 크기는 누가 결정하는가 ?  
3. 가상 메모리의 크기는 왜 포인터의 크기를 따라가는가 ?  
4. 물리 메모리의 최소 단위와 단편화 문제  
5. 그냥 다이렉트 맵핑하면 되지 가상 메모리가 왜 필요한가 ?  

## 비트 수 기반으로 가상 메모리 표기하기

먼저 1비트의 변수가 가상 메모리를 표현한다 가정하면 아래와 같이 표시할 수 있을 것이다.  
1 bit -> 2 byte: 2^1  
2 bit -> 4 byte: 2^2  

이것을 보면 ??? 왜 ? 라는 생각이 먼저 들 것이다.  
정해진 것이 아닌 (가상) 메모리 이기 때문에 규칙을 그냥 저렇게 맵핑한 것이다.  
(가상 메모리를 표기하기 위한 새로운 규칙을 만든것 뿐)  
그렇다면 10 bit 를 표기한다 가정해보자!  

위의 규칙을 따르면 10 bit -> 2^10 byte가 된다.  
실제로 아래와 같은 단위 규칙이 있다.  

```make
이 부분은 실제 규칙입니다.

2^10 byte = 1 KB
2^10 KB = 1 MB
2^10 MB = 1 GB
```

위의 실제 규칙에 우리가 가상 메모리를 도입하기 위해 적용한 규칙을 함께 적용하면 아래와 같이 표현할 수 있다.  
10 bit -> 2^10 byte == 1 KB  
20 bit -> 2^20 byte == 2^10 KB == 1 MB  
30 bit -> 2^30 byte == 2^20 KB == 2^10 MB == 1 GB  
32 bit -> 1GB x 2^2 == 4 GB  

## 포인터의 크기는 누가 결정하는가 ?

포인터의 크기는 실제 하드웨어 레지스터를 포함하고 있는 ALU가 결정합니다.  
왜냐하면 연산할 수 있는 최대치가 결국 ALU에 있는 범용 레지스터에 의해 결정되기 때문이다.  
(ALU는 Arithmetic Logic Unit이라 해서 컴퓨터의 연산을 담당하는 하드웨어 로직이라고 보면 됩니다.)  

실제 하드웨어 레지스터는 인텔의 경우 rax, rbx, rcx, rdx와 같은 형식으로 나타나며  
ARM의 경우엔 r0, r1, r2, r3, ... 형식으로 나타난다.  

여기서 또 다른 오해가 발생할 수 있는데 펌웨어 개발을 하다보면 펌웨어를 제어하기 위한 레지스터가 존재한다.  
현재 케이스에서 거론되는 레지스터는 연산용 레지스터이므로 펌웨어를 제어하기 위한 레지스터와는 별개입니다.  
(실제로 펌웨어는 ARM아키텍처이므로 범용 레지스터는 r0, r1, r2, ... 형식으로 활용됨)  

그렇기 때문에 64 비트 운영체제에서는 범용 레지스터가 64비트이므로 포인터의 크기가 8 바이트가 된다.  
범용 레지스터는 실제 프로그램이 구동되는데 필요한 레지스터이며  
제어 레지스터는 특정한 하드웨어를 구동시키기 위한 옵션이라고 생각하면 된다.  

## 범용 레지스터 vs peripheral 제어 레지스터  

둘의 구별 해야 합니다.  
실제 프로그램이 구동될때 동작하는 CPU 연산은 범용 레지스터가 담당합니다.  
반면 Peripheral 의 장치를 활성하고 제어하는 목적으로는 Peripheral 제어 레지스터가 활용됩니다.  

## 가상 메모리의 크기는 왜 포인터의 크기를 따라가는가 ?

범용 레지스터의 크기가 64비트이므로 표현할 수 있는 바이트는 8 바이트에 해당합니다.  
그렇다면 하드웨어 특성상 여기서 64비트를 모두 활용하지 않는 것은 비용 낭비에 해당할 것입니다.  
안 그래도 반도체 공정상 비싼 하드웨어에 속도가 빠른 범용 레지스터는 그 가격의 손해가 더욱 클 것입니다.  
그래서 64비트를 다 안쓰고 35비트 정도만 사용한다면 엄청난 손해를 보는 격입니다.  

그러므로 64비트를 모두 포함하면서 효율적으로 사용할 수 있는 방법을 찾고자 했습니다.  
가만 보니 가상 메모리를 64비트로 표현하면 8바이트를 모두 표현할 수 있었던 것입니다.  

## 물리 메모리의 최소 단위와 단편화 문제

물리 메모리의 최소 단위는 페이지 프레임(Page Frame)이라고 하여 4 KB(4096 바이트)를 기본 단위로 지정합니다.  
이때 우리가 메모리를 마구잡이로 할당하고 관리하게 되면 어떤일이 발생할지 생각해 보는 것입니다.  
프로그램에서 사용하는 메모리 크기가 80 바이트 짜리를 수만번 할당한다고 가정해봅니다.

페이지 프레임에 80 바이트를 저장함  
그리고 다른 페이지 프레임에 또 다시 80 바이트를 저장합니다.  
단편화(Fragmentation)이 발생함  

4096 - 80 = 4012바이트의 손해가 발생함  

대충 곱하기 10000을 하면 40120000 => 40 MB의 손해가 발생합니다.  
80 * 10000 = 800000 => 사용량은 800 KB 밖에 안됩니다.  

이런 상황이 발생하다보니 메모리를 관리할 수 있는 시스템이 필요해짐  
그것의 일환으로 버디 할당자와 슬랩 할당자가 등장하게 됨  
아래와 같이 작은 단위의 메모리 할당이 필요한 경우 슬랩 할당자가 동작해서 쪼개서 값을 나눠주며  
반대 값이 큰 메모리를 할당할 경우엔 버디 할당자가 동작해서 여러 페이지 프레임을 제공해주는 방식으로 동작하게 됨  

프로세스들이 여러개가 같이 돌기 시작하는 상황임  
이 경우엔 물리 메모리에 서로 값을 쓰겠다고 충돌이 미친듯이 발생하게 됨  
이것을 전반적으로 유연하게 관리해줄 무언가가 필요했고  
그것으로 페이징 정책을 택해 가상 메모리 <-> 물리 메모리 방식을 채택했다고 봐도 무방함  

## 그냥 다이렉트 맵핑하면 되지 가상 메모리가 왜 필요한가 ?

다이렉트로 맵핑을 하였는데 다음에 들어오는 데이터가  
기존에 다이렉트 맵핑한 메모리 데이터 보다 더 큰 것이 들어온다면 ???  
답이 없는 상황이 도출된다는 것을 바로 알 수 있다.  

끝도 없이 대규모 데이터가 빈번하게 들어오는 레이더 시스템이나  
영상 시스템 같은 경우엔 다이렉트 맵핑을 한다는 것 자체가 말도 안되는 이야기가 되는 것임  

가상 메모리 시스템에서는 물리 메모리로 변환한 데이터를 페이지라고 하는데  
필요에 따라서 /swap 파티션에 이 페이지 데이터를 캐싱해두는 목적으로 활용하게 된다.  

