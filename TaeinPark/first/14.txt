
함수 호출 할 때 발생하는 어셈블리 특성??

함수 호출에서 가장 중요하다고 생각 되는 놈은 역시

callq 인 것 같다.

callq는 함수 호출을 하기전에 전 스택의 rsp-8 위치에
복귀주소(호출 했던 함수에서 돌아 올 때 넘어가야 할 다음 메모리 주소)
를 push 한 뒤 jump 하는 명령어 이다.

그리고 돌아올 이전 함수의 rbp가 복귀주소의 아래에 저장된다.

예를 들면 아래와 같음 모습.

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ㅣ      0x0(rbp)                ㅣ 0x0x7fffffffdf90  
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ 
ㅣ      0x3(num)                ㅣ 0x0x7fffffffdf88
 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ㅣ                              ㅣ 0x0x7fffffffdf80
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
   ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ㅣ  0x0000555555555178(복귀주소) ㅣ 0x0x7fffffffdf78
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ㅣ 0x0x7fffffffdf90(이전 함수의 rbp)ㅣ 0x0x7fffffffdf70 <- rsp
  ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

아직까지는 rbp가 바뀌지 않았다.

그러나, 새로운 함수를 호출하게 되면
rsp -> rbp, 즉, 새로운 rbp가 생성된다. 이것이 새로운 함수의 스택 기준점이 된다.
그리고 새로운 함수의 메모리가 새롭게 할당 되어 새로운 스택을 (아래로)쌓게 된다.
이 곳만의 rbp, rsp가 새로이 생성 되는 것이다.

다시 원래의 함수로 돌아올 때에는
pop %rbp 명령어가 사용 되어
rsp에서 값을 빼서 rbp로 값을 넘겨 준다.
리턴 값이 이런식으로 넘어 간다.

빼내는 방식은 rsp를 위로 올라 가게 만들고
70 -> 78로 가게 한다. 

그리고 retq 가 실행 되면 
retq는 pop rip 이라는 의미로 rsp에서 값을 빼서 rip에 주는 것이다.

rip은 다음에 실행하게 될 명령이므로
rip에 복귀 주소가 들어가게 됨으로써 저장 되어 있던
복귀 주소로 함수는 복귀 하게 된다.




